import{Q as n}from"./QPage.f5df25c2.js";import{Q as i}from"./index.esm.ba0f6273.js";import{_ as r,m as l,q as c,s as h,t as d,u as m,B as e,C as s,v as u,A as o}from"./index.1290fcd1.js";import"./QBtn.70c0b5f7.js";import"./position-engine.e08c2a66.js";import"./selection.8e7a3623.js";import"./scroll.f8823e45.js";const p=l({name:"PhysarumPage",components:{QMarkdown:i},data(){return{split:60,markdown:`\`\`\`
float sense(float x, float y, float r, float offset)
{
    float sensorAngle = r + offset;
    vec2 sensorDirection = vec2(cos(sensorAngle), sin(sensorAngle));
    vec2 sensorCentre = vec2(x, y) + sensorDirection * sensorOffsetDistance;

    float sum = 0.0;
    for (float i = -sensorWidth; i <= sensorWidth; i += 1.0/width)
    {
        for (float j = -sensorHeight; j <= sensorHeight; j += 1.0/height)
        {
            vec4 reading = texture(renderTex, sensorCentre + vec2(i, j));
            sum += reading.r + reading.g + reading.b;
        }
    }
    return sum / maxPossibleReading;
}
\`\`\``}}}),g={class:"q-mt-none q-mb-lg text-primary"},f=e("div",{class:"text-h4"},"Physarum Polycephalum Simulation",-1),_=e("br",null,null,-1),v=e("p",null,[o(" I learned a lot of the conceptual details for this project from "),e("a",{href:"http://cargocollective.com/sagejenson/physarum",class:"text-accent",target:"_blank"},"Sage Jenson's write-up"),o(" on the topic as well as "),e("a",{href:"https://www.youtube.com/watch?v=X-iSQQgOd1A",class:"text-accent",target:"_blank"}," Sebastian Lague's video"),o(". ")],-1),y=[v],w=e("p",null," Physarum Polycephalum is a single-celled organism which, within large networks, can together exhibit many complex and intelligent locomotive behaviours. The project involved creating webGL shaders to simulate 100,000s of 'agents', each with a set of simple navigational rules, on the GPU to create complex collective behaviour. ",-1),b=e("p",null," Each agent (or particle) moves based on 3 sensor readings around it (front left, front & front right). The sensors each read the brightness of the pixel they are currently on, and the agent will then move in the direction of the brightest reading (or randomly if two are equal or all read dark). ",-1),x=e("p",null," The agent then deposits some material onto the pixel it is currently on, which increases that pixel's brightness. The entire trail map then decays (is darkened slightly) and dissipates (blurred) using a simple 3x3 blur algorithm. ",-1),P=e("p",null," Each sensor reads pixel values in a small box surrounding it, and that normalised value is compared between the 3 sensors. ",-1),k=e("div",{class:"text-caption"}," Excerpt from the agent movement shader: Given the agent position and sensor angle and offset, returns a normalised reading of the pixel values in the area around a sensor. ",-1),q=e("div",{class:"text-h6"},"Dynamic Agent Speed",-1),j=e("p",null,` A feature which I wanted to focus on, which I had not seen much of elsewhere, was giving the agents dynamic speeds based on their surroundings. Here, an agent's acceleration is proportional to the brightness of the readings around it. This causes them to form "highways" of high-speed lanes with many agents moving through, and regions agents slowing moving into empty territory. Here, the agent's acceleration also affects their colour. `,-1),A=e("p",null," I doubt that this feature is scientifically accurate to the real-life molds though, which seem to move pretty slowly constantly. ",-1);function C(t,T,$,Q,S,B){const a=m("q-markdown");return c(),h(n,null,{default:d(()=>[e("div",g,[f,_,e("div",{class:s(["focused",t.$q.platform.is.mobile?"":"aside"])},y,2),w,e("video",{class:s(t.$q.platform.is.mobile?"center-mobile":"aside"),autoplay:"",loop:"",src:"portfolio/slime_vid_1.mp4",muted:""},null,2),b,x,P,u(a,{style:{"line-height":"1.5",overflow:"auto","overflow-x":"auto","min-width":"0px","box-sizing":"border-box"},src:t.markdown,class:"focused"},null,8,["src"]),k,q,e("video",{class:s(t.$q.platform.is.mobile?"center-mobile":"aside"),autoplay:"",loop:"",src:"portfolio/slime_vid_2.mp4",muted:""},null,2),j,A])]),_:1})}var z=r(p,[["render",C]]);export{z as default};
